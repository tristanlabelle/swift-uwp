// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Creates a media session and binds license acquisition to that media session.
public final class WindowsMediaProtectionPlayReady_PlayReadyLicenseSession: WindowsRuntime.WinRTImport<WindowsMediaProtectionPlayReady_PlayReadyLicenseSessionProjection>, WindowsMediaProtectionPlayReady_IPlayReadyLicenseSessionProtocol, WindowsMediaProtectionPlayReady_IPlayReadyLicenseSession2Protocol {
    // MARK: Windows.Media.Protection.PlayReady.IPlayReadyLicenseSessionFactory members

    public convenience init(_ configuration: WindowsFoundationCollections_IPropertySet?) throws {
        self.init(_transferringRef: try COM.NullResult.unwrap(Self._iplayReadyLicenseSessionFactory.createInstance(configuration)))
    }

    // MARK: Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession members

    /// Creates a license acquisition service request whose license will be tied to the media session.
    /// - Returns: The license acquisition service request.
    public func createLAServiceRequest() throws -> WindowsMediaProtectionPlayReady_IPlayReadyLicenseAcquisitionServiceRequest {
        try COM.NullResult.unwrap(_interop.createLAServiceRequest())
    }

    /// Updates the media protection manger with the appropriate settings so the media foundation can be used for playback.
    /// - Parameter mpm: The media protection manager to be updated.
    public func configureMediaProtectionManager(_ mpm: WindowsMediaProtection_MediaProtectionManager?) throws {
        try _interop.configureMediaProtectionManager(mpm)
    }

    // MARK: Windows.Media.Protection.PlayReady.IPlayReadyLicenseSession2 members

    /// Creates a PlayReadyLicense class iterator that supports in-memory-only PlayReady licenses in addition to persisted licenses.
    /// - Parameter contentHeader: The content header used to locate associated licenses.
    /// - Parameter fullyEvaluated: Indicates whether evaluated license chains should be enumerated or if all licenses (including those that are unusable) should be enumerated. Set this parameter to true if evaluated license chains should be enumerated. Set this parameter to false if all licenses should be enumerated.
    public func createLicenseIterable(_ contentHeader: WindowsMediaProtectionPlayReady_PlayReadyContentHeader?, _ fullyEvaluated: Swift.Bool) throws -> WindowsMediaProtectionPlayReady_PlayReadyLicenseIterable {
        try COM.NullResult.unwrap(_iplayReadyLicenseSession2.createLicenseIterable(contentHeader, fullyEvaluated))
    }

    // MARK: Implementation details

    private var _iplayReadyLicenseSession2_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSession2>? = nil

    internal var _iplayReadyLicenseSession2: COM.COMInterop<CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSession2> {
        get throws {
            try _iplayReadyLicenseSession2_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSession2.iid).cast(to: CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSession2.self)
            }
        }
    }

    deinit {
        _iplayReadyLicenseSession2_storage?.release()
    }

    private static var _iplayReadyLicenseSessionFactory_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSessionFactory>? = nil

    internal static var _iplayReadyLicenseSessionFactory: COM.COMInterop<CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSessionFactory> {
        get throws {
            try _iplayReadyLicenseSessionFactory_storage.lazyInit {
                try WindowsRuntime.getActivationFactoryPointer(activatableId: "Windows.Media.Protection.PlayReady.PlayReadyLicenseSession", id: CWinRT.SWRT_WindowsMediaProtectionPlayReady_IPlayReadyLicenseSessionFactory.iid)
            }
        }
    }
}