// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Represents the source of adaptive streaming content.
public final class WindowsMediaStreamingAdaptive_AdaptiveMediaSource: WindowsRuntime.WinRTImport<WindowsMediaStreamingAdaptive_AdaptiveMediaSourceProjection>, WindowsMediaCore_IMediaSourceProtocol, WindowsFoundation_IClosableProtocol {
    // MARK: Windows.Media.Streaming.Adaptive.IAdaptiveMediaSource members

    /// Gets a value indicating if the content streamed by the media source contains only audio.
    /// - Returns: True if the content only contains audio; otherwise, false.
    public var audioOnlyPlayback: Swift.Bool {
        get throws {
            try _interop.get_AudioOnlyPlayback()
        }
    }

    /// Gets the available adaptive bit rates of the adaptive streaming manifest that is the source of the adaptive streaming object.
    /// - Returns: The list of available adaptive bit rates of the adaptive streaming manifest.
    public var availableBitrates: WindowsFoundationCollections_IVectorView<Swift.UInt32> {
        get throws {
            try COM.NullResult.unwrap(_interop.get_AvailableBitrates())
        }
    }

    /// Gets a value indicating the current download bitrate for the media source.
    /// - Returns: The current download bitrate for the media source.
    public var currentDownloadBitrate: Swift.UInt32 {
        get throws {
            try _interop.get_CurrentDownloadBitrate()
        }
    }

    /// Gets a value indicating the current playback bitrate for the media source.
    /// - Returns: The current playback bitrate for the media source.
    public var currentPlaybackBitrate: Swift.UInt32 {
        get throws {
            try _interop.get_CurrentPlaybackBitrate()
        }
    }

    /// Gets or sets the desired offset of live playback from the end of the known media content that has been downloaded.
    /// - Returns: The desired offset for the live playback of the streaming media. This value must be greater than MinLiveOffset. If the specified value is less than the minimum value, it is automatically clamped to the allowed range.
    public var desiredLiveOffset: WindowsFoundation_TimeSpan {
        get throws {
            try _interop.get_DesiredLiveOffset()
        }
    }

    /// Gets or sets the desired offset of live playback from the end of the known media content that has been downloaded.
    /// - Returns: The desired offset for the live playback of the streaming media. This value must be greater than MinLiveOffset. If the specified value is less than the minimum value, it is automatically clamped to the allowed range.
    public func desiredLiveOffset(_ value: WindowsFoundation_TimeSpan) throws {
        try _interop.put_DesiredLiveOffset(value)
    }

    /// Gets or sets the desired maximum bitrate for the media source.
    /// - Returns: The desired maximum bitrate for the streaming media.
    public var desiredMaxBitrate: Swift.UInt32? {
        get throws {
            try _interop.get_DesiredMaxBitrate()
        }
    }

    /// Gets or sets the desired maximum bitrate for the media source.
    /// - Returns: The desired maximum bitrate for the streaming media.
    public func desiredMaxBitrate(_ value: Swift.UInt32?) throws {
        try _interop.put_DesiredMaxBitrate(value)
    }

    /// Gets or sets the desired minimum bitrate for the media source.
    /// - Returns: The desired minimum bitrate for the streaming media.
    public var desiredMinBitrate: Swift.UInt32? {
        get throws {
            try _interop.get_DesiredMinBitrate()
        }
    }

    /// Gets or sets the desired minimum bitrate for the media source.
    /// - Returns: The desired minimum bitrate for the streaming media.
    public func desiredMinBitrate(_ value: Swift.UInt32?) throws {
        try _interop.put_DesiredMinBitrate(value)
    }

    /// Gets a value indicating the inbound bits per second statistic over the time window specified by the InboundBitsPerSecondWindow property.
    /// - Returns: The inbound bits per second over the InboundBitsPerSecondWindow time span.
    public var inboundBitsPerSecond: Swift.UInt64 {
        get throws {
            try _interop.get_InboundBitsPerSecond()
        }
    }

    /// Gets or sets the time span over which the InboundBitsPerSecond property is calculated.
    /// - Returns: The time span over which the InboundBitsPerSecond property is calculated.
    public var inboundBitsPerSecondWindow: WindowsFoundation_TimeSpan {
        get throws {
            try _interop.get_InboundBitsPerSecondWindow()
        }
    }

    /// Gets or sets the time span over which the InboundBitsPerSecond property is calculated.
    /// - Returns: The time span over which the InboundBitsPerSecond property is calculated.
    public func inboundBitsPerSecondWindow(_ value: WindowsFoundation_TimeSpan) throws {
        try _interop.put_InboundBitsPerSecondWindow(value)
    }

    /// Gets and sets the initial bit rate to use for playback of the media source.
    /// - Returns: The initial bit rate to use for playback.
    public var initialBitrate: Swift.UInt32 {
        get throws {
            try _interop.get_InitialBitrate()
        }
    }

    /// Gets and sets the initial bit rate to use for playback of the media source.
    /// - Returns: The initial bit rate to use for playback.
    public func initialBitrate(_ value: Swift.UInt32) throws {
        try _interop.put_InitialBitrate(value)
    }

    /// Gets a value that indicates whether the media source is live.
    /// - Returns: A value that indicates whether playback of the adaptive streaming object is live. **true** if live; otherwise, **false**.
    public var isLive: Swift.Bool {
        get throws {
            try _interop.get_IsLive()
        }
    }

    /// Occurs when the CurrentDownloadBitrate changes.
    public func downloadBitrateChanged(adding handler: WindowsFoundation_TypedEventHandler<WindowsMediaStreamingAdaptive_AdaptiveMediaSource?, WindowsMediaStreamingAdaptive_AdaptiveMediaSourceDownloadBitrateChangedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_DownloadBitrateChanged(handler)
        return WindowsRuntime.EventRegistration(token: _token, remover: downloadBitrateChanged)
    }

    public func downloadBitrateChanged(removing token: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_DownloadBitrateChanged(token)
    }

    /// Occurs when a resource download operation completes
    public func downloadCompleted(adding handler: WindowsFoundation_TypedEventHandler<WindowsMediaStreamingAdaptive_AdaptiveMediaSource?, WindowsMediaStreamingAdaptive_AdaptiveMediaSourceDownloadCompletedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_DownloadCompleted(handler)
        return WindowsRuntime.EventRegistration(token: _token, remover: downloadCompleted)
    }

    public func downloadCompleted(removing token: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_DownloadCompleted(token)
    }

    /// Occurs when a resource download operation fails.
    public func downloadFailed(adding handler: WindowsFoundation_TypedEventHandler<WindowsMediaStreamingAdaptive_AdaptiveMediaSource?, WindowsMediaStreamingAdaptive_AdaptiveMediaSourceDownloadFailedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_DownloadFailed(handler)
        return WindowsRuntime.EventRegistration(token: _token, remover: downloadFailed)
    }

    public func downloadFailed(removing token: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_DownloadFailed(token)
    }

    /// Occurs when a resource download operation is requested.
    public func downloadRequested(adding handler: WindowsFoundation_TypedEventHandler<WindowsMediaStreamingAdaptive_AdaptiveMediaSource?, WindowsMediaStreamingAdaptive_AdaptiveMediaSourceDownloadRequestedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_DownloadRequested(handler)
        return WindowsRuntime.EventRegistration(token: _token, remover: downloadRequested)
    }

    public func downloadRequested(removing token: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_DownloadRequested(token)
    }

    /// Occurs when the CurrentPlaybackBitrate changes.
    public func playbackBitrateChanged(adding handler: WindowsFoundation_TypedEventHandler<WindowsMediaStreamingAdaptive_AdaptiveMediaSource?, WindowsMediaStreamingAdaptive_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_PlaybackBitrateChanged(handler)
        return WindowsRuntime.EventRegistration(token: _token, remover: playbackBitrateChanged)
    }

    public func playbackBitrateChanged(removing token: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_PlaybackBitrateChanged(token)
    }

    // MARK: Windows.Media.Streaming.Adaptive.IAdaptiveMediaSource2 members

    /// Gets the advanced settings for the adaptive media source.
    /// - Returns: The advanced settings for the adaptive media source.
    public var advancedSettings: WindowsMediaStreamingAdaptive_AdaptiveMediaSourceAdvancedSettings {
        get throws {
            try COM.NullResult.unwrap(_iadaptiveMediaSource2.get_AdvancedSettings())
        }
    }

    // MARK: Windows.Media.Streaming.Adaptive.IAdaptiveMediaSource3 members

    /// Gets or sets the requested maximum size of the time window within which the user can seek within the streaming media.
    /// - Returns: The requested maximum size of the time window in which the user can seek within the streaming media. This value must be between zero and the value of MaxSeekableWindowSize. If the specified value is greater than the maximum value, the system automatically clamps to the allowed range, but when you retrieve the property it will return the unclamped value.
    public var desiredSeekableWindowSize: WindowsFoundation_IReference<WindowsFoundation_TimeSpan>? {
        get throws {
            try _iadaptiveMediaSource3.get_DesiredSeekableWindowSize()
        }
    }

    /// Gets or sets the requested maximum size of the time window within which the user can seek within the streaming media.
    /// - Returns: The requested maximum size of the time window in which the user can seek within the streaming media. This value must be between zero and the value of MaxSeekableWindowSize. If the specified value is greater than the maximum value, the system automatically clamps to the allowed range, but when you retrieve the property it will return the unclamped value.
    public func desiredSeekableWindowSize(_ value: WindowsFoundation_IReference<WindowsFoundation_TimeSpan>?) throws {
        try _iadaptiveMediaSource3.put_DesiredSeekableWindowSize(value)
    }

    /// Gets an object that provides an event that is raised when diagnostic information about the adaptive media source is available.
    /// - Returns: An object that provides an event that is raised when diagnostic information about the adaptive media source is available.
    public var diagnostics: WindowsMediaStreamingAdaptive_AdaptiveMediaSourceDiagnostics {
        get throws {
            try COM.NullResult.unwrap(_iadaptiveMediaSource3.get_Diagnostics())
        }
    }

    /// Gets the maximum time window within which the user can seek within the streaming media.
    /// - Returns: The maximum time window within which the user can seek within the streaming media.
    public var maxSeekableWindowSize: WindowsFoundation_IReference<WindowsFoundation_TimeSpan>? {
        get throws {
            try _iadaptiveMediaSource3.get_MaxSeekableWindowSize()
        }
    }

    /// Gets the minimum offset of live playback from the end of the known media content that has been downloaded.
    /// - Returns: The minimum offset of live playback from the end of the known media content that has been downloaded.
    public var minLiveOffset: WindowsFoundation_IReference<WindowsFoundation_TimeSpan>? {
        get throws {
            try _iadaptiveMediaSource3.get_MinLiveOffset()
        }
    }

    /// Gets an object that provides timing information that is correlated between timestamps in the media or date/time information from the manifest with the presentation clock timeline.
    /// - Returns: An object that provides correlated timing information for the adaptive media source.
    public func getCorrelatedTimes() throws -> WindowsMediaStreamingAdaptive_AdaptiveMediaSourceCorrelatedTimes {
        try COM.NullResult.unwrap(_iadaptiveMediaSource3.getCorrelatedTimes())
    }

    // MARK: Windows.Foundation.IClosable members

    /// Closes the adaptive media source and frees up associated resources.
    public func close() throws {
        try _iclosable.close()
    }

    // MARK: Windows.Media.Streaming.Adaptive.IAdaptiveMediaSourceStatics members

    /// Determines whether the content type of the source is supported.
    /// - Parameter contentType: A string that identifies the content type of the source. Can be a Http Live Streaming (HLS) or Dynamic Adaptive Streaming over HTTP (DASH) content type.
    /// - Returns: Returns a value that indicates whether the content type of the source is supported. **true** if supported; otherwise, **false**.
    public static func isContentTypeSupported(_ contentType: Swift.String) throws -> Swift.Bool {
        try _iadaptiveMediaSourceStatics.isContentTypeSupported(contentType)
    }

    /// Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
    /// - Parameter uri: T he Uniform Resource Identifier (URI) of the source.
    /// - Returns: Returns an AdaptiveMediaSourceCreationResult upon successful completion.
    public static func createFromUriAsync(_ uri: WindowsFoundation_Uri?) throws -> WindowsFoundation_IAsyncOperation<WindowsMediaStreamingAdaptive_AdaptiveMediaSourceCreationResult?> {
        try COM.NullResult.unwrap(_iadaptiveMediaSourceStatics.createFromUriAsync(uri))
    }

    /// Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
    /// - Parameter uri: The Uniform Resource Identifier (URI) of the source.
    /// - Parameter httpClient: The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
    /// - Returns: Returns an AdaptiveMediaSourceCreationResult upon successful completion.
    public static func createFromUriAsync(_ uri: WindowsFoundation_Uri?, _ httpClient: WindowsWebHttp_HttpClient?) throws -> WindowsFoundation_IAsyncOperation<WindowsMediaStreamingAdaptive_AdaptiveMediaSourceCreationResult?> {
        try COM.NullResult.unwrap(_iadaptiveMediaSourceStatics.createFromUriWithDownloaderAsync(uri, httpClient))
    }

    /// Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
    /// - Parameter stream: The input stream from which the AdaptiveMediaSource is created.
    /// - Parameter uri: The Uniform Resource Identifier (URI) of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
    /// - Parameter contentType: A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
    /// - Returns: Returns an AdaptiveMediaSourceCreationResult upon successful completion.
    public static func createFromStreamAsync(_ stream: WindowsStorageStreams_IInputStream?, _ uri: WindowsFoundation_Uri?, _ contentType: Swift.String) throws -> WindowsFoundation_IAsyncOperation<WindowsMediaStreamingAdaptive_AdaptiveMediaSourceCreationResult?> {
        try COM.NullResult.unwrap(_iadaptiveMediaSourceStatics.createFromStreamAsync(stream, uri, contentType))
    }

    /// Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
    /// - Parameter stream: The input stream from which the AdaptiveMediaSource is created.
    /// - Parameter uri: The Uniform Resource Identifier (URI) of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
    /// - Parameter contentType: A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
    /// - Parameter httpClient: The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
    /// - Returns: Returns an AdaptiveMediaSourceCreationResult upon successful completion.
    public static func createFromStreamAsync(_ stream: WindowsStorageStreams_IInputStream?, _ uri: WindowsFoundation_Uri?, _ contentType: Swift.String, _ httpClient: WindowsWebHttp_HttpClient?) throws -> WindowsFoundation_IAsyncOperation<WindowsMediaStreamingAdaptive_AdaptiveMediaSourceCreationResult?> {
        try COM.NullResult.unwrap(_iadaptiveMediaSourceStatics.createFromStreamWithDownloaderAsync(stream, uri, contentType, httpClient))
    }

    // MARK: Implementation details

    private var _imediaSource_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaCore_IMediaSource>? = nil

    internal var _imediaSource: COM.COMInterop<CWinRT.SWRT_WindowsMediaCore_IMediaSource> {
        get throws {
            try _imediaSource_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsMediaCore_IMediaSource.iid).cast(to: CWinRT.SWRT_WindowsMediaCore_IMediaSource.self)
            }
        }
    }

    private var _iadaptiveMediaSource2_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource2>? = nil

    internal var _iadaptiveMediaSource2: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource2> {
        get throws {
            try _iadaptiveMediaSource2_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource2.iid).cast(to: CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource2.self)
            }
        }
    }

    private var _iadaptiveMediaSource3_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource3>? = nil

    internal var _iadaptiveMediaSource3: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource3> {
        get throws {
            try _iadaptiveMediaSource3_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource3.iid).cast(to: CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSource3.self)
            }
        }
    }

    private var _iclosable_storage: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable>? = nil

    internal var _iclosable: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable> {
        get throws {
            try _iclosable_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsFoundation_IClosable.iid).cast(to: CWinRT.SWRT_WindowsFoundation_IClosable.self)
            }
        }
    }

    deinit {
        _imediaSource_storage?.release()
        _iadaptiveMediaSource2_storage?.release()
        _iadaptiveMediaSource3_storage?.release()
        _iclosable_storage?.release()
    }

    private static var _iadaptiveMediaSourceStatics_storage: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSourceStatics>? = nil

    internal static var _iadaptiveMediaSourceStatics: COM.COMInterop<CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSourceStatics> {
        get throws {
            try _iadaptiveMediaSourceStatics_storage.lazyInit {
                try WindowsRuntime.getActivationFactoryPointer(activatableId: "Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", id: CWinRT.SWRT_WindowsMediaStreamingAdaptive_IAdaptiveMediaSourceStatics.iid)
            }
        }
    }
}