// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// A decompressor takes a stream compressed by a compressor and decompresses it.
public final class WindowsStorageCompression_Decompressor: WindowsRuntime.WinRTImport<WindowsStorageCompression_DecompressorProjection>, WindowsStorageStreams_IInputStreamProtocol, WindowsFoundation_IClosableProtocol {
    // MARK: Windows.Storage.Compression.IDecompressorFactory members

    public convenience init(_ underlyingStream: WindowsStorageStreams_IInputStream?) throws {
        self.init(_transferringRef: try COM.NullResult.unwrap(Self._idecompressorFactory.createDecompressor(underlyingStream)))
    }

    // MARK: Windows.Storage.Compression.IDecompressor members

    /// Detaches the underlying stream from the Decompressor object so that the object can be closed using the Decompressor.Close method without also closing the underlying stream.
    /// - Returns: The stream of information.
    public func detachStream() throws -> WindowsStorageStreams_IInputStream {
        try COM.NullResult.unwrap(_interop.detachStream())
    }

    // MARK: Windows.Storage.Streams.IInputStream members

    /// Reads from the compression stream asynchronously.
    /// - Parameter buffer: The buffer that contains the information to be read from the stream.
    /// - Parameter count: The number of bytes to read.
    /// - Parameter options: Read options
    /// - Returns: The asynchronous operation.
    public func readAsync(_ buffer: WindowsStorageStreams_IBuffer?, _ count: Swift.UInt32, _ options: WindowsStorageStreams_InputStreamOptions) throws -> WindowsFoundation_IAsyncOperationWithProgress<WindowsStorageStreams_IBuffer?, Swift.UInt32> {
        try COM.NullResult.unwrap(_iinputStream.readAsync(buffer, count, options))
    }

    // MARK: Windows.Foundation.IClosable members

    /// Closes a Decompressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Decompressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except , will fail.
    public func close() throws {
        try _iclosable.close()
    }

    // MARK: Implementation details

    private var _iinputStream_storage: COM.COMInterop<CWinRT.SWRT_WindowsStorageStreams_IInputStream>? = nil

    internal var _iinputStream: COM.COMInterop<CWinRT.SWRT_WindowsStorageStreams_IInputStream> {
        get throws {
            try _iinputStream_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsStorageStreams_IInputStream.iid).cast(to: CWinRT.SWRT_WindowsStorageStreams_IInputStream.self)
            }
        }
    }

    private var _iclosable_storage: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable>? = nil

    internal var _iclosable: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable> {
        get throws {
            try _iclosable_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsFoundation_IClosable.iid).cast(to: CWinRT.SWRT_WindowsFoundation_IClosable.self)
            }
        }
    }

    deinit {
        _iinputStream_storage?.release()
        _iclosable_storage?.release()
    }

    private static var _idecompressorFactory_storage: COM.COMInterop<CWinRT.SWRT_WindowsStorageCompression_IDecompressorFactory>? = nil

    internal static var _idecompressorFactory: COM.COMInterop<CWinRT.SWRT_WindowsStorageCompression_IDecompressorFactory> {
        get throws {
            try _idecompressorFactory_storage.lazyInit {
                try WindowsRuntime.getActivationFactoryPointer(activatableId: "Windows.Storage.Compression.Decompressor", id: CWinRT.SWRT_WindowsStorageCompression_IDecompressorFactory.iid)
            }
        }
    }
}