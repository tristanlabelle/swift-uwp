// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Specifies status values for a socket operation.
public struct WindowsNetworkingSockets_SocketErrorStatus: RawRepresentable, Hashable, Codable {
    public var rawValue: Swift.Int32

    public init(rawValue: Swift.Int32 = 0) {
        self.rawValue = rawValue
    }

    /// The socket status is unknown.
    public static let unknown = Self()

    /// The operation was aborted.
    public static let operationAborted = Self(rawValue: 1)

    /// A bad response was received from the HTTP server.
    public static let httpInvalidServerResponse = Self(rawValue: 2)

    /// A connection timeout was exceeded.
    public static let connectionTimedOut = Self(rawValue: 3)

    /// The address family is not supported.
    public static let addressFamilyNotSupported = Self(rawValue: 4)

    /// The socket type is not supported.
    public static let socketTypeNotSupported = Self(rawValue: 5)

    /// The host was not found.
    public static let hostNotFound = Self(rawValue: 6)

    /// The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for.
    public static let noDataRecordOfRequestedType = Self(rawValue: 7)

    /// This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.
    public static let nonAuthoritativeHostNotFound = Self(rawValue: 8)

    /// The specified class was not found.
    public static let classTypeNotFound = Self(rawValue: 9)

    /// The address is already in use.
    public static let addressAlreadyInUse = Self(rawValue: 10)

    /// Cannot assign requested address.
    public static let cannotAssignRequestedAddress = Self(rawValue: 11)

    /// The connection was refused.
    public static let connectionRefused = Self(rawValue: 12)

    /// The network is unreachable.
    public static let networkIsUnreachable = Self(rawValue: 13)

    /// The host is unreachable.
    public static let unreachableHost = Self(rawValue: 14)

    /// The network is down.
    public static let networkIsDown = Self(rawValue: 15)

    /// The network dropped connection on reset.
    public static let networkDroppedConnectionOnReset = Self(rawValue: 16)

    /// Software caused a connection abort.
    public static let softwareCausedConnectionAbort = Self(rawValue: 17)

    /// The connection was reset by the peer.
    public static let connectionResetByPeer = Self(rawValue: 18)

    /// The host is down.
    public static let hostIsDown = Self(rawValue: 19)

    /// The pipe is being closed.
    public static let noAddressesFound = Self(rawValue: 20)

    /// Too many open files.
    public static let tooManyOpenFiles = Self(rawValue: 21)

    /// A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram was smaller than the datagram itself.
    public static let messageTooLong = Self(rawValue: 22)

    /// A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file. This error is also returned if the validity periods of the certification chain do not nest correctly.
    public static let certificateExpired = Self(rawValue: 23)

    /// A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider. This error is also returned if a certificate chain could not be built to a trusted root authority.
    public static let certificateUntrustedRoot = Self(rawValue: 24)

    /// The certificate is not valid for the requested usage. This error is also returned if the certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded.
    public static let certificateCommonNameIsIncorrect = Self(rawValue: 25)

    /// The certificate is not valid for the requested usage.
    public static let certificateWrongUsage = Self(rawValue: 26)

    /// A certificate was explicitly revoked by its issuer. This error is also returned if the certificate was explicitly marked as untrusted by the user.
    public static let certificateRevoked = Self(rawValue: 27)

    /// The revocation function was unable to check revocation for the certificate.
    public static let certificateNoRevocationCheck = Self(rawValue: 28)

    /// The revocation function was unable to check revocation because the revocation server was offline.
    public static let certificateRevocationServerOffline = Self(rawValue: 29)

    /// The supplied certificate is invalid. This can be returned for a number of reasons:
    public static let certificateIsInvalid = Self(rawValue: 30)
}