// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Supports network communication that allows reading and writing whole messages using a WebSocket.
public final class WindowsNetworkingSockets_MessageWebSocket: WindowsRuntime.WinRTImport<WindowsNetworkingSockets_MessageWebSocketProjection>, WindowsNetworkingSockets_IWebSocketProtocol, WindowsFoundation_IClosableProtocol {
    // MARK: IActivationFactory members

    public convenience init() throws {
        self.init(_transferringRef: try Self._iactivationFactory.activateInstance(projection: WindowsNetworkingSockets_MessageWebSocketProjection.self))
    }

    // MARK: Windows.Networking.Sockets.IMessageWebSocket members

    /// Gets socket control data on a MessageWebSocket object.
    /// - Returns: Socket control data on a MessageWebSocket object.
    public var control: WindowsNetworkingSockets_MessageWebSocketControl {
        get throws {
            try COM.NullResult.unwrap(_interop.get_Control())
        }
    }

    /// Gets socket information on a MessageWebSocket object.
    /// - Returns: Socket information on a MessageWebSocket object.
    public var information: WindowsNetworkingSockets_MessageWebSocketInformation {
        get throws {
            try COM.NullResult.unwrap(_interop.get_Information())
        }
    }

    /// An event that indicates that a message was received on the MessageWebSocket object.
    public func messageReceived(adding eventHandler: WindowsFoundation_TypedEventHandler<WindowsNetworkingSockets_MessageWebSocket?, WindowsNetworkingSockets_MessageWebSocketMessageReceivedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _interop.add_MessageReceived(eventHandler)
        return WindowsRuntime.EventRegistration(token: _token, remover: messageReceived)
    }

    public func messageReceived(removing eventCookie: WindowsRuntime.EventRegistrationToken) throws {
        try _interop.remove_MessageReceived(eventCookie)
    }

    // MARK: Windows.Networking.Sockets.IWebSocket members

    /// Gets the output stream to write to the remote network destination on a MessageWebSocket object.
    /// - Returns: A sequential stream of bytes to be written to the remote destination as a single message.
    public var outputStream: WindowsStorageStreams_IOutputStream {
        get throws {
            try COM.NullResult.unwrap(_iwebSocket.get_OutputStream())
        }
    }

    /// Occurs when a close frame is received on the MessageWebSocket object as part of the close handshake.
    public func closed(adding eventHandler: WindowsFoundation_TypedEventHandler<WindowsNetworkingSockets_IWebSocket?, WindowsNetworkingSockets_WebSocketClosedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _iwebSocket.add_Closed(eventHandler)
        return WindowsRuntime.EventRegistration(token: _token, remover: closed)
    }

    public func closed(removing eventCookie: WindowsRuntime.EventRegistrationToken) throws {
        try _iwebSocket.remove_Closed(eventCookie)
    }

    /// Starts an asynchronous operation to connect to a remote network destination on a MessageWebSocket object.
    /// - Parameter uri: An absolute Uri for the server to connect to.
    /// - Returns: An asynchronous connect operation on a MessageWebSocket object.
    public func connectAsync(_ uri: WindowsFoundation_Uri?) throws -> WindowsFoundation_IAsyncAction {
        try COM.NullResult.unwrap(_iwebSocket.connectAsync(uri))
    }

    /// Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the MessageWebSocket object.
    /// - Parameter headerName: The name of the request header.
    /// - Parameter headerValue: The value of the request header.
    public func setRequestHeader(_ headerName: Swift.String, _ headerValue: Swift.String) throws {
        try _iwebSocket.setRequestHeader(headerName, headerValue)
    }

    /// Closes the MessageWebSocket object and indicates a reason for the closure.
    /// - Parameter code: Status code indicating the reason for closure. The list of appropriate codes is on the IANA (Internet Assigned Numbers Authority) WebSocket Protocol Registry and is also documented on MDN.
    /// - Parameter reason: Optional UTF-8-encoded data with additional information about the closure.
    public func close(_ code: Swift.UInt16, _ reason: Swift.String) throws {
        try _iwebSocket.closeWithStatus(code, reason)
    }

    // MARK: Windows.Foundation.IClosable members

    /// Closes the MessageWebSocket object and sends an empty close frame to the server.
    public func close() throws {
        try _iclosable.close()
    }

    // MARK: Windows.Networking.Sockets.IMessageWebSocket2 members

    /// Occurs when a new MessageWebSocket connection to a secured server URI (**wss:** protocol) is being validated. Handle this event if you want to implement custom server validation for the connection.
    public func serverCustomValidationRequested(adding eventHandler: WindowsFoundation_TypedEventHandler<WindowsNetworkingSockets_MessageWebSocket?, WindowsNetworkingSockets_WebSocketServerCustomValidationRequestedEventArgs?>?) throws -> WindowsRuntime.EventRegistration {
        let _token = try _imessageWebSocket2.add_ServerCustomValidationRequested(eventHandler)
        return WindowsRuntime.EventRegistration(token: _token, remover: serverCustomValidationRequested)
    }

    public func serverCustomValidationRequested(removing eventCookie: WindowsRuntime.EventRegistrationToken) throws {
        try _imessageWebSocket2.remove_ServerCustomValidationRequested(eventCookie)
    }

    // MARK: Windows.Networking.Sockets.IMessageWebSocket3 members

    /// Asynchronously (with progress) writes a frame of data in a sequential stream, with the semantics that more frames will follow for the same WebSocket message (the FIN bit on this frame is set to 0). This method and SendFinalFrameAsync allow you to send individual WebSocket frames.
    /// - Parameter data: A buffer containing the data that constitutes the frame to be sent.
    /// - Returns: An asynchronous byte writer operation with progress.
    public func sendNonfinalFrameAsync(_ data: WindowsStorageStreams_IBuffer?) throws -> WindowsFoundation_IAsyncOperationWithProgress<Swift.UInt32, Swift.UInt32> {
        try COM.NullResult.unwrap(_imessageWebSocket3.sendNonfinalFrameAsync(data))
    }

    /// Asynchronously (with progress) writes a frame of data in a sequential stream, with the semantics that this is the last frame in a WebSocket message (the FIN bit on this frame is set to 1). This method and SendNonfinalFrameAsync allow you to send individual WebSocket frames.
    /// - Parameter data: A buffer containing the data that constitutes the frame to be sent.
    /// - Returns: An asynchronous byte writer operation with progress.
    public func sendFinalFrameAsync(_ data: WindowsStorageStreams_IBuffer?) throws -> WindowsFoundation_IAsyncOperationWithProgress<Swift.UInt32, Swift.UInt32> {
        try COM.NullResult.unwrap(_imessageWebSocket3.sendFinalFrameAsync(data))
    }

    // MARK: Implementation details

    private var _iwebSocket_storage: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IWebSocket>? = nil

    internal var _iwebSocket: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IWebSocket> {
        get throws {
            try _iwebSocket_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsNetworkingSockets_IWebSocket.iid).cast(to: CWinRT.SWRT_WindowsNetworkingSockets_IWebSocket.self)
            }
        }
    }

    private var _iclosable_storage: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable>? = nil

    internal var _iclosable: COM.COMInterop<CWinRT.SWRT_WindowsFoundation_IClosable> {
        get throws {
            try _iclosable_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsFoundation_IClosable.iid).cast(to: CWinRT.SWRT_WindowsFoundation_IClosable.self)
            }
        }
    }

    private var _imessageWebSocket2_storage: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket2>? = nil

    internal var _imessageWebSocket2: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket2> {
        get throws {
            try _imessageWebSocket2_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket2.iid).cast(to: CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket2.self)
            }
        }
    }

    private var _imessageWebSocket3_storage: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket3>? = nil

    internal var _imessageWebSocket3: COM.COMInterop<CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket3> {
        get throws {
            try _imessageWebSocket3_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket3.iid).cast(to: CWinRT.SWRT_WindowsNetworkingSockets_IMessageWebSocket3.self)
            }
        }
    }

    deinit {
        _iwebSocket_storage?.release()
        _iclosable_storage?.release()
        _imessageWebSocket2_storage?.release()
        _imessageWebSocket3_storage?.release()
    }

    private static var _iactivationFactory_storage: COM.COMInterop<CWinRT.SWRT_IActivationFactory>? = nil

    internal static var _iactivationFactory: COM.COMInterop<CWinRT.SWRT_IActivationFactory> {
        get throws {
            try _iactivationFactory_storage.lazyInit {
                try WindowsRuntime.getActivationFactoryPointer(activatableId: "Windows.Networking.Sockets.MessageWebSocket", id: CWinRT.SWRT_IActivationFactory.iid)
            }
        }
    }
}