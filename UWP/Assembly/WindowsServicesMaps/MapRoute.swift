// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Represents a path to be traveled between two or more waypoints.
public final class WindowsServicesMaps_MapRoute: WindowsRuntime.WinRTImport<WindowsServicesMaps_MapRouteProjection> {
    // MARK: Windows.Services.Maps.IMapRoute members

    /// Gets the bounding box that contains the route.
    /// - Returns: The bounding box that contains the route.
    public var boundingBox: WindowsDevicesGeolocation_GeoboundingBox {
        get throws {
            try COM.NullResult.unwrap(_interop.get_BoundingBox())
        }
    }

    /// Gets the estimated time required to traverse the route.
    /// - Returns: The estimated time required to traverse the route.
    public var estimatedDuration: WindowsFoundation_TimeSpan {
        get throws {
            try _interop.get_EstimatedDuration()
        }
    }

    /// Gets a value indicating whether the MapRoute is based on traffic.
    /// - Returns: **true** if the MapRoute is based on traffic; otherwise, **false**.
    public var isTrafficBased: Swift.Bool {
        get throws {
            try _interop.get_IsTrafficBased()
        }
    }

    /// Gets the list of legs associated with the route.
    /// - Returns: The list of legs associated with the route. This property returns a collection of MapRouteLeg objects.
    public var legs: WindowsFoundationCollections_IVectorView<WindowsServicesMaps_MapRouteLeg?> {
        get throws {
            try COM.NullResult.unwrap(_interop.get_Legs())
        }
    }

    /// Gets the length of the route in meters.
    /// - Returns: The length of the route in meters.
    public var lengthInMeters: Swift.Double {
        get throws {
            try _interop.get_LengthInMeters()
        }
    }

    /// Gets the path of the route.
    /// - Returns: The path of the route.
    public var path: WindowsDevicesGeolocation_Geopath {
        get throws {
            try COM.NullResult.unwrap(_interop.get_Path())
        }
    }

    // MARK: Windows.Services.Maps.IMapRoute2 members

    /// Gets a value that indicates the route has been modified from the "best" route to avoid blocked roads.
    /// - Returns: **true** if the route has been modified to avoid blocked roads; otherwise, **false**.
    public var hasBlockedRoads: Swift.Bool {
        get throws {
            try _imapRoute2.get_HasBlockedRoads()
        }
    }

    /// Gets a value that indicates if any restrictions have been violated by the route.
    /// - Returns: The MapRouteRestrictions that have been violated by the route.
    public var violatedRestrictions: WindowsServicesMaps_MapRouteRestrictions {
        get throws {
            try _imapRoute2.get_ViolatedRestrictions()
        }
    }

    // MARK: Windows.Services.Maps.IMapRoute3 members

    /// Gets the estimated time required to traverse the route without traffic.
    /// - Returns: The estimated time required to traverse the route without traffic.
    public var durationWithoutTraffic: WindowsFoundation_TimeSpan {
        get throws {
            try _imapRoute3.get_DurationWithoutTraffic()
        }
    }

    /// Gets the level of traffic congestion along a map route.
    /// - Returns: The level of traffic congestion along a map route.
    public var trafficCongestion: WindowsServicesMaps_TrafficCongestion {
        get throws {
            try _imapRoute3.get_TrafficCongestion()
        }
    }

    // MARK: Windows.Services.Maps.IMapRoute4 members

    /// Gets a value that indicates whether the MapRoute is based on scenic roads.
    /// - Returns: **true** if the MapRoute is based on scenic roads; otherwise, **false**.
    public var isScenic: Swift.Bool {
        get throws {
            try _imapRoute4.get_IsScenic()
        }
    }

    // MARK: Implementation details

    private var _imapRoute2_storage: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute2>? = nil

    internal var _imapRoute2: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute2> {
        get throws {
            try _imapRoute2_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsServicesMaps_IMapRoute2.iid).cast(to: CWinRT.SWRT_WindowsServicesMaps_IMapRoute2.self)
            }
        }
    }

    private var _imapRoute3_storage: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute3>? = nil

    internal var _imapRoute3: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute3> {
        get throws {
            try _imapRoute3_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsServicesMaps_IMapRoute3.iid).cast(to: CWinRT.SWRT_WindowsServicesMaps_IMapRoute3.self)
            }
        }
    }

    private var _imapRoute4_storage: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute4>? = nil

    internal var _imapRoute4: COM.COMInterop<CWinRT.SWRT_WindowsServicesMaps_IMapRoute4> {
        get throws {
            try _imapRoute4_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsServicesMaps_IMapRoute4.iid).cast(to: CWinRT.SWRT_WindowsServicesMaps_IMapRoute4.self)
            }
        }
    }

    deinit {
        _imapRoute2_storage?.release()
        _imapRoute3_storage?.release()
        _imapRoute4_storage?.release()
    }
}