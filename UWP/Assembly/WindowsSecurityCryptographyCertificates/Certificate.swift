// Generated by swift-winrt
// swiftlint:disable all

import CWinRT
import WindowsRuntime
import UWP
import struct Foundation.UUID

/// Represents a cryptography certificate.
public final class WindowsSecurityCryptographyCertificates_Certificate: WindowsRuntime.WinRTImport<WindowsSecurityCryptographyCertificates_CertificateProjection> {
    // MARK: Windows.Security.Cryptography.Certificates.ICertificateFactory members

    public convenience init(_ certBlob: WindowsStorageStreams_IBuffer?) throws {
        self.init(_transferringRef: try COM.NullResult.unwrap(Self._icertificateFactory.createCertificate(certBlob)))
    }

    // MARK: Windows.Security.Cryptography.Certificates.ICertificate members

    /// Gets a collection of object identifiers (OIDs) for the enhanced key usage extension.
    /// - Returns: A collection of object identifiers (OIDs) for the enhanced key usage extension
    public var enhancedKeyUsages: WindowsFoundationCollections_IVectorView<Swift.String> {
        get throws {
            try COM.NullResult.unwrap(_interop.get_EnhancedKeyUsages())
        }
    }

    /// Gets or sets the friendly name for the certificate.
    /// - Returns: The friendly name for the certificate. If the certificate does not have a friendly name set, then an empty string is returned.
    public var friendlyName: Swift.String {
        get throws {
            try _interop.get_FriendlyName()
        }
    }

    /// Gets or sets the friendly name for the certificate.
    /// - Returns: The friendly name for the certificate. If the certificate does not have a friendly name set, then an empty string is returned.
    public func friendlyName(_ value: Swift.String) throws {
        try _interop.put_FriendlyName(value)
    }

    /// Gets a value indicating whether the certificate has a private key.
    /// - Returns: True if the certificate has a private key; otherwise false.
    public var hasPrivateKey: Swift.Bool {
        get throws {
            try _interop.get_HasPrivateKey()
        }
    }

    /// Gets a value that indicates whether the private key associated with the certificate is strongly protected.
    /// - Returns: True if the certificate is strongly protected; otherwise false.
    public var isStronglyProtected: Swift.Bool {
        get throws {
            try _interop.get_IsStronglyProtected()
        }
    }

    /// Gets the name of the certificate issuer.
    /// - Returns: The name of the certificate issuer.
    public var issuer: Swift.String {
        get throws {
            try _interop.get_Issuer()
        }
    }

    /// Gets the serial number of the certificate.
    /// - Returns: The serial number of the certificate.
    public var serialNumber: [Swift.UInt8] {
        get throws {
            try _interop.get_SerialNumber()
        }
    }

    /// Gets the subject name of the certificate.
    /// - Returns: The subject name of the certificate.
    public var subject: Swift.String {
        get throws {
            try _interop.get_Subject()
        }
    }

    /// Gets the date and time after which the certificate is valid.
    /// - Returns: The date and time after which the certificate is valid.
    public var validFrom: WindowsFoundation_DateTime {
        get throws {
            try _interop.get_ValidFrom()
        }
    }

    /// Gets the date and time after which the certificate is no longer valid.
    /// - Returns: The date and time after which the certificate is no longer valid.
    public var validTo: WindowsFoundation_DateTime {
        get throws {
            try _interop.get_ValidTo()
        }
    }

    public func buildChainAsync(_ certificates: WindowsFoundationCollections_IIterable<WindowsSecurityCryptographyCertificates_Certificate?>?) throws -> WindowsFoundation_IAsyncOperation<WindowsSecurityCryptographyCertificates_CertificateChain?> {
        try COM.NullResult.unwrap(_interop.buildChainAsync(certificates))
    }

    public func buildChainAsync(_ certificates: WindowsFoundationCollections_IIterable<WindowsSecurityCryptographyCertificates_Certificate?>?, _ parameters: WindowsSecurityCryptographyCertificates_ChainBuildingParameters?) throws -> WindowsFoundation_IAsyncOperation<WindowsSecurityCryptographyCertificates_CertificateChain?> {
        try COM.NullResult.unwrap(_interop.buildChainWithParametersAsync(certificates, parameters))
    }

    /// Gets the SHA1 hash value for the certificate.
    /// - Returns: The SHA1 hash value for the certificate.
    public func getHashValue() throws -> [Swift.UInt8] {
        try _interop.getHashValue()
    }

    /// Gets the hash value for the certificate for a specified algorithm.
    /// - Parameter hashAlgorithmName: The hash algorithm to use for the hash value of the certificate. Only values of "SHA1" or "SHA256" are supported. To get the SHA2 hash value for the certificate, specify "SHA256".
    /// - Returns: The hash value of the certificate.
    public func getHashValue(_ hashAlgorithmName: Swift.String) throws -> [Swift.UInt8] {
        try _interop.getHashValueWithAlgorithm(hashAlgorithmName)
    }

    /// Gets the ASN.1 DER encoded certificate blob.
    /// - Returns: The ASN.1 DER encoded certificate blob.
    public func getCertificateBlob() throws -> WindowsStorageStreams_IBuffer {
        try COM.NullResult.unwrap(_interop.getCertificateBlob())
    }

    // MARK: Windows.Security.Cryptography.Certificates.ICertificate2 members

    /// Gets whether the security device is bound.
    /// - Returns: True if the security device is bound; otherwise, false.
    public var isSecurityDeviceBound: Swift.Bool {
        get throws {
            try _icertificate2.get_IsSecurityDeviceBound()
        }
    }

    /// Gets the name of the cryptographic algorithm used to create the key.
    /// - Returns: The name of the cryptographic algorithm used to create the key.
    public var keyAlgorithmName: Swift.String {
        get throws {
            try _icertificate2.get_KeyAlgorithmName()
        }
    }

    /// Gets the key uses for the certificate.
    /// - Returns: The key uses for the certificate.
    public var keyUsages: WindowsSecurityCryptographyCertificates_CertificateKeyUsages {
        get throws {
            try COM.NullResult.unwrap(_icertificate2.get_KeyUsages())
        }
    }

    /// Gets the signature algorithm name.
    /// - Returns: The signature algorithm name.
    public var signatureAlgorithmName: Swift.String {
        get throws {
            try _icertificate2.get_SignatureAlgorithmName()
        }
    }

    /// Gets the signature hash algorithm name.
    /// - Returns: The signature hash algorithm name.
    public var signatureHashAlgorithmName: Swift.String {
        get throws {
            try _icertificate2.get_SignatureHashAlgorithmName()
        }
    }

    /// Gets info on the subject alternative name.
    /// - Returns: Info on the subject alternative name.
    public var subjectAlternativeName: WindowsSecurityCryptographyCertificates_SubjectAlternativeNameInfo {
        get throws {
            try COM.NullResult.unwrap(_icertificate2.get_SubjectAlternativeName())
        }
    }

    // MARK: Windows.Security.Cryptography.Certificates.ICertificate3 members

    /// Gets whether the certificate is per-user.
    /// - Returns: True if the certificate is per-user; otherwise, false.
    public var isPerUser: Swift.Bool {
        get throws {
            try _icertificate3.get_IsPerUser()
        }
    }

    /// Gets the certificate's key storage provider name.
    /// - Returns: The certificate's key storage provider name.
    public var keyStorageProviderName: Swift.String {
        get throws {
            try _icertificate3.get_KeyStorageProviderName()
        }
    }

    /// Gets the certificate's store name.
    /// - Returns: The certificate's store name.
    public var storeName: Swift.String {
        get throws {
            try _icertificate3.get_StoreName()
        }
    }

    // MARK: Implementation details

    private var _icertificate2_storage: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate2>? = nil

    internal var _icertificate2: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate2> {
        get throws {
            try _icertificate2_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate2.iid).cast(to: CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate2.self)
            }
        }
    }

    private var _icertificate3_storage: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate3>? = nil

    internal var _icertificate3: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate3> {
        get throws {
            try _icertificate3_storage.lazyInit {
                try _queryInterfacePointer(CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate3.iid).cast(to: CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificate3.self)
            }
        }
    }

    deinit {
        _icertificate2_storage?.release()
        _icertificate3_storage?.release()
    }

    private static var _icertificateFactory_storage: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificateFactory>? = nil

    internal static var _icertificateFactory: COM.COMInterop<CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificateFactory> {
        get throws {
            try _icertificateFactory_storage.lazyInit {
                try WindowsRuntime.getActivationFactoryPointer(activatableId: "Windows.Security.Cryptography.Certificates.Certificate", id: CWinRT.SWRT_WindowsSecurityCryptographyCertificates_ICertificateFactory.iid)
            }
        }
    }
}